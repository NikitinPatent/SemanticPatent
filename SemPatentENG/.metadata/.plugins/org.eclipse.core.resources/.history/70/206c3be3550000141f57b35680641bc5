package org.parser;

import edu.stanford.nlp.ling.HasWord;
import edu.stanford.nlp.ling.TaggedWord;
import edu.stanford.nlp.process.Morphology;
import edu.stanford.nlp.tagger.maxent.MaxentTagger;

import org.annolab.tt4j.*;
import org.maltparser.MaltParserService;
import org.maltparser.core.exception.MaltChainedException;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.InputSource;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;

import java.io.*;
import java.math.BigDecimal;
import java.math.RoundingMode;
import java.net.URL;
import java.net.URLConnection;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.Iterator;
import java.util.regex.*;

import static java.util.Arrays.asList;

public class SemParser {
    private static String symbolTab = "\t";
    private static String magSymbol = "\n";//символ переноса строки возможно будет заменен другиим символом
    public static String namePatent="PatentNumber";
    
    public static List<String> terms;
    
    public static HashMap<Integer,String> listConllQ; // предложения заявки
    //public static HashMap<Integer,String> listConllP; 
    public static HashMap<String,HashMap<Integer,String>> listConllP; // предложения патента
    
    public static HashMap<Integer,HashMap<String, ArrayList<Integer>>>  resRej; // ссылки на релевантные предложения
    public static HashMap<Integer,HashMap<String, ArrayList<Integer>>>  resAcc; // ссылки на новизну

    public static String outCompareRes = "";

    static float koef1; // Коэффициент совпадения поддеревьев (на подобие)
    static float koef2; // Коэффициент различий в совпадающих деревьях (на различие)
    static float koef3; // Коэффициент совпадения связок слов (на подобие)
    
    //Учитываем размер заявки и патента
    static float koef11; // Коэффициент совпадения поддеревьев (на подобие)
    static float koef21; // Коэффициент различий в совпадающих деревьях (на различие)
    static float koef31; // Коэффициент совпадения связок слов (на подобие)
    
    static float koef4; // Количество деревьев в заявке и патенте

    public static void shouldAcceptENG() throws IOException{

        Path currentRelativePath = Paths.get("");
        String absolutePath = currentRelativePath.toAbsolutePath().toString();

        String separator = File.separator;
        String modelNameMalt = "engmalt.linear-1.7";

        String resultClaim = fileRead("claim_en0.txt");
        resultClaim = Segment.segmentEng(resultClaim);
        //fileWrite("text_en0.txt", resultClaim);
        resultClaim = Stanford.StanfordTagger(resultClaim);
        resultClaim = Conll.conllEng(resultClaim);
        //fileWrite("conll_en0.txt", resultClaim);
        resultClaim = MaltParser.maltParserEng(modelNameMalt, resultClaim);
        fileWrite("malt_en0.txt", resultClaim);
        
        File file1 = new File("parser.log");
        file1.delete();

    }

    public static void sortMap(Map<Integer,String> map) {
        Set s = map.entrySet();
        Iterator it = s.iterator();
        while ( it.hasNext() ) {
           Map.Entry entry = (Map.Entry) it.next();
           Integer key = (Integer) entry.getKey();
           String value = (String) entry.getValue();
        }//while
    }
    
    /** fileWrite - запись документа из строки в файл
     *
     * Входные параметры:
     * String fileName - полный путь с именем файла, куда записывать данные
     * String content - документ записи.
     *
     * Выходные данные:
     *
     */
    public static void fileWrite(String fileName, String content){
        try
        {
            OutputStream f = new FileOutputStream(fileName, false);
            OutputStreamWriter writer = new OutputStreamWriter(f, "UTF-8");
            BufferedWriter out = new BufferedWriter(writer);
            out.write(content);
            out.flush();
            f.close();
            writer.close();
        }
        catch(IOException ex)
        {
            System.err.println(ex);
        }
    }

    /** fileRead - читает весь документ в строковую переменную
     *
     * Входные параметры:
     * String fileName - полный путь с именем файла (если указать просто имя файла, то документ создастся рядом с
     * исполняемым файлом)
     *
     * Выходные данные:
     * String - полный тестовый документ, считаный по строчно и разделенный символом переноса строки
     */
    public static String fileRead(String fileName){
        String result = "";
        BufferedReader input = null;

        try {
            input = new BufferedReader(new InputStreamReader(new FileInputStream(fileName), "UTF-8"));
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
        } catch (FileNotFoundException e) {
            e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
        }

        try {
            String tmp;
            while ((tmp = input.readLine()) != null){
                result += tmp;
                result += "\n";
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        try {
            input.close();
        } catch (IOException e) {
            e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
        }
        return result;
    }
    
}
